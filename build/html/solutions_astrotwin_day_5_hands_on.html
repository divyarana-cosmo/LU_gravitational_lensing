

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Day 5 Solutions &mdash; AstroTwinColo_2024 2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/nbsphinx-code-cells.css?v=2aa19091" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=6fefd858"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            AstroTwinColo_2024
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="astrotwin_day_1_hands_on.html">Day 1 - Introduction</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">AstroTwinColo_2024</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Day 5 Solutions</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/solutions_astrotwin_day_5_hands_on.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Day-5-Solutions">
<h1>Day 5 Solutions<a class="headerlink" href="#Day-5-Solutions" title="Link to this heading"></a></h1>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#loading the required packages
%matplotlib inline
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import cKDTree
from astropy.cosmology import FlatLambdaCDM
import glob
<br/></pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def get_xyz(ra, dec):
    ra = ra*np.pi/180.
    dec = dec*np.pi/180.
    x = np.cos(dec)*np.cos(ra)
    y = np.cos(dec)*np.sin(ra)
    z = np.sin(dec)
    return x, y, z
<br/></pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(get_xyz(30,60))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(0.43301270189221946, 0.25, 0.8660254037844386)
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># selection cut on the lens sample
def lens_select(zmin=0.1, zmax=0.33, rsepmin=0.1, rsepmax=0.4):
    #please check the file path properly
    data = pd.read_csv(&#39;/home/idies/workspace/Storage/divyar/AstroTwin_Colo_2024/DataStore/redmapper_satellites.dat&#39;, delim_whitespace=1)
    #sample selection cut
    idx  = (data[&#39;rsep[h-1Mpc]&#39;]&gt;rsepmin) &amp; (data[&#39;rsep[h-1Mpc]&#39;]&lt;=rsepmax)
    idx  = idx &amp; (data[&#39;zred&#39;]&gt;zmin) &amp; (data[&#39;zred&#39;]&lt;=zmax)
    ra   = data[&#39;ra&#39;].values[idx]
    dec  = data[&#39;dec&#39;].values[idx]
    zred = data[&#39;zred&#39;].values[idx]
    #as we have no weights to apply we set them to unity
    wgt  = ra*1.0/ra
    print(&#39;number of lenses=%d&#39;%len(ra))
    return ra, dec, zred, wgt



# def lens_select(zmin=0.1, zmax=0.33, lammin=55, lammax=100):
#     #please check the file path properly
#     data = pd.read_csv(&#39;/home/idies/workspace/Storage/divyar/AstroTwin_Colo_2024/DataStore/redmapper.dat&#39;, delim_whitespace=1)
#     #sample selection cut
#     idx  = (data[&#39;lambda&#39;]&gt;lammin) &amp; (data[&#39;lambda&#39;]&lt;=lammax)
#     idx  = idx &amp; (data[&#39;zred&#39;]&gt;zmin) &amp; (data[&#39;zred&#39;]&lt;=zmax)
#     ra   = data[&#39;ra&#39;].values[idx]
#     dec  = data[&#39;dec&#39;].values[idx]
#     zred = data[&#39;zred&#39;].values[idx]
#     #as we have no weights to apply we set them to unity
#     wgt  = ra*1.0/ra
#     print(&#39;number of lenses=%d&#39;%len(ra))
#     return ra, dec, zred, wgt
<br/></pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># sanity cheaks on the source files
def read_sources(ifil):
    # various columns in sources
    # ragal, decgal, e1gal, e2gal, wgal, rms_egal, mgal, c1gal, c2gal, R2gal, zphotgal
    data = pd.read_csv(ifil, delim_whitespace=1).values
    zphotgal = data[:,-1]
    # sanity checks on the sources data
    idx = (np.sum(np.isnan(data), axis=1)==0) &amp;  (zphotgal&gt;0)
    datagal = np.zeros((np.sum(idx),7))
    datagal[:,:6] = data[idx,:6]
    datagal[:,6]  = data[idx,-1]
    # collects only -  ragal, decgal, e1gal, e2gal, wgal, rms_egal, zphotgal
    return datagal
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># following surhud&#39;s lectures
def get_et(lra, ldec, sra, sdec, se1, se2):
    lra  = lra*np.pi/180
    ldec = ldec*np.pi/180
    sra  = sra*np.pi/180
    sdec = sdec*np.pi/180

    c_theta = np.cos(ldec)*np.cos(sdec)*np.cos(lra - sra) + np.sin(ldec)*np.sin(sdec)
    s_theta = np.sqrt(1-c_theta**2)

    # phi to get the compute the tangential shear
    c_phi   = np.cos(ldec)*np.sin(sra - lra)*1.0/s_theta
    s_phi   = (-np.sin(ldec)*np.cos(sdec) + np.cos(ldec)*np.cos(sra - lra)*np.sin(sdec))*1.0/s_theta
    # tangential shear
    e_t     = - se1*(2*c_phi**2 -1) - se2*(2*c_phi * s_phi)

    return e_t
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(get_et(lra=0, ldec=0, sra=0.123, sdec=0.045, se1 = 4.5e-2, se2 = 1.7e-2))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
-0.04534629189830734
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def get_sigma_crit_inv(lzred, szred, cc):
    # some important constants for the sigma crit computations
    gee = 4.301e-9 #km^2 Mpc M_sun^-1 s^-2 gravitational constant
    cee = 3e5 #km s^-1
    # sigma_crit_calculations for a given lense-source pair
    sigm_crit_inv = cc.angular_diameter_distance(lzred).value * cc.angular_diameter_distance_z1z2(lzred, szred).value * (1.0 + lzred)**2 * 1.0/cc.angular_diameter_distance(szred).value
    sigm_crit_inv = sigm_crit_inv * 4*np.pi*gee*1.0/cee**2
    sigm_crit_inv = 1e12*sigm_crit_inv #esd&#39;s are in pc not in Mpc

    return sigm_crit_inv
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from astropy.cosmology import FlatLambdaCDM
cc = FlatLambdaCDM(H0=100, Om0=0.999)
print(get_sigma_crit_inv(lzred=0.33, szred=0.8, cc=cc))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.00030436585298495184
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><br/><span></span>def run_pipe(Omegam=0.315, rmin=0.2, rmax=2.0, nbins=10, zdiff=0.4, outputfile = &#39;astrotwin_dsigma.dat&#39;):
    #set the cosmology with omegaM parameter
    cc = FlatLambdaCDM(H0=100, Om0=Omegam) # fixing H0=100 to set units in Mpc h-1

    # set the projected radial binning
    rmin  =  rmin
    rmax  =  rmax
    nbins = nbins #10 radial bins for our case
    rbins  = np.logspace(np.log10(rmin), np.log10(rmax), nbins + 1)
    rdiff  = np.log10(rbins[1]*1.0/rbins[0])

    # initializing arrays for signal compuations
    sumdsig_num   = np.zeros(len(rbins[:-1]))
    sumdsigsq_num = np.zeros(len(rbins[:-1]))
    sumwls        = np.zeros(len(rbins[:-1]))
    sumwls_resp   = np.zeros(len(rbins[:-1]))

    # getting the lenses data
    lra, ldec, lred, lwgt = lens_select()
    #lra, ldec, lred, lwgt = lens_select(zmin=0.1, zmax=0.33, lammin=55, lammax=100)

    # convert lense ra and dec into x,y,z cartesian coordinates
    lx, ly, lz = get_xyz(lra, ldec)

    # putting kd tree around the lenses
    lens_tree = cKDTree(np.array([lx, ly, lz]).T)


    print(&#39;lenses tree is ready\n&#39;)

    # setting maximum search radius
    dcommin = cc.comoving_distance(np.min(lred)).value
    dismax  = (rmax*1.0/(dcommin))

    # lets first catch the file list for sources
    sflist = np.sort(glob.glob(&#39;/home/idies/workspace/Storage/divyar/AstroTwin_Colo_2024/DataStore/hsc/*.dat&#39;))

    # Ready to pounce on the source data
    for ifil in sflist:
        # catching the source data matrix
        # please have a check for the columns names
        datagal = read_sources(ifil)
        Ngal = len(datagal[:,0])  # total number of galaxies in the source file
        # first two entries are ra and dec for the sources
        allragal  = datagal[:,0]
        alldecgal = datagal[:,1]
        # ra and dec to x,y,z for sources
        allsx, allsy, allsz = get_xyz(allragal, alldecgal)
        # query in a ball around individual sources and collect the lenses ids with a maximum radius
        slidx = lens_tree.query_ball_point(np.transpose([allsx, allsy, allsz]), dismax)
        # various columns in sources
        # ragal, decgal, e1gal, e2gal, wgal, rms_egal, mgal, c1gal, c2gal, R2gal, zphotgal
        # looping over all the galaxies
        for igal in range(Ngal):
            ragal    = datagal[igal,0]
            decgal   = datagal[igal,1]
            e1gal    = datagal[igal,2]
            e2gal    = datagal[igal,3]
            wgal     = datagal[igal,4]
            rms_egal = datagal[igal,5]
            zphotgal = datagal[igal,6]

            # array of lenses indices
            lidx = np.array(slidx[igal])
            # removing sources which doesn&#39;t have any lenses around them
            if len(lidx)==0:
                continue

            # selecting a cleaner background
            zcut = (lred[lidx] &lt; (zphotgal - zdiff)) #only taking the foreground lenses
            # again skipping the onces which doesn&#39;t satisfy the above criteria
            if np.sum(zcut)==0.0:
                continue
            # collecting the  data of lenses around individual source
            lidx   = lidx[zcut] # this will catch the array indices for our lenses
            sra    = ragal
            sdec   = decgal

            l_ra   = lra[lidx]
            l_dec  = ldec[lidx]
            l_zred = lred[lidx]
            l_wgt  = lwgt[lidx]

            sx, sy, sz = get_xyz(sra,sdec) # individual galaxy ra,dec--&gt;x,y,z
            lx, ly, lz = get_xyz(l_ra,l_dec) # individual galaxy ra,dec--&gt;x,y,z

            # getting the radial separations for a lense source pair
            sl_sep = np.sqrt((lx - sx)**2 + (ly - sy)**2 + (lz - sz)**2)
            sl_sep = sl_sep * cc.comoving_distance(l_zred).value
            for ll,sep in enumerate(sl_sep):
                if sep&lt;rmin or sep&gt;rmax:
                    continue
                rb = int(np.log10(sep*1.0/rmin)*1/rdiff)

                # get tangantial components given positions and shapes
                e_t = get_et(lra = l_ra[ll], ldec = l_dec[ll], sra = sra, sdec = sdec, se1 = e1gal,  se2 = e2gal)

                # sigma_crit_calculations for a given lense-source pair
                sigm_crit_inv = get_sigma_crit_inv(l_zred[ll], zphotgal, cc)

                # following equations given in the surhud&#39;s lectures
                w_ls    = l_wgt[ll] * wgal * (sigm_crit_inv)**2
                w_ls_by_av_sigc_inv = l_wgt[ll] * wgal * sigm_crit_inv

                # separate numerator and denominator computation
                sumdsig_num[rb]   += w_ls_by_av_sigc_inv  * e_t
                sumdsigsq_num[rb] += (w_ls_by_av_sigc_inv * e_t)**2
                sumwls[rb]        += w_ls
                sumwls_resp[rb]   += w_ls * (1-rms_egal**2)

        print(ifil)


    fout = open(outputfile, &quot;w&quot;)
    fout.write(&quot;# 0:rmin/2+rmax/2 1:DeltaSigma 2:SN_ErrDeltaSigma\n&quot;)
    for i in range(len(rbins[:-1])):
        rrmin = rbins[i]
        rrmax = rbins[i+1]
        Resp = sumwls_resp[i]*1.0/sumwls[i]

        fout.write(&quot;%le\t%le\t%le\n&quot;%(rrmin/2.0+rrmax/2.0, sumdsig_num[i]*1.0/sumwls[i]/2./Resp, np.sqrt(sumdsigsq_num[i])*1.0/sumwls[i]/2./Resp))
    fout.write(&quot;#OK&quot;)
    fout.close()

    return 0
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#run_pipe(rmin=0.01,rmax=3, outputfile = &#39;/home/idies/workspace/Storage/divyar/persistent/astrotwin_dsigma_satellite.dat&#39;)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>dat = np.loadtxt(&#39;astrotwin_dsigma_satellite.dat&#39;)

plt.errorbar(dat[:,0], dat[:,1], yerr=dat[:,2], fmt=&#39;.&#39;, capsize=3, label=&#39;Data&#39;)
plt.legend()

plt.xlabel(r&#39;$R[{\rm h^{-1}Mpc}]$&#39;)
plt.ylabel(r&#39;$\Delta\Sigma [{\rm h M_\odot pc^{-2}}]$&#39;)
plt.xscale(&#39;log&#39;)
plt.yscale(&#39;log&#39;)
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>dat = np.loadtxt(&#39;astrotwin_dsigma.dat&#39;)

plt.errorbar(dat[:,0], dat[:,1], yerr=dat[:,2], fmt=&#39;.&#39;, capsize=3, label=&#39;Data&#39;)
plt.legend()

plt.xlabel(r&#39;$R[{\rm h^{-1}Mpc}]$&#39;)
plt.ylabel(r&#39;$\Delta\Sigma [{\rm h M_\odot pc^{-2}}]$&#39;)
plt.xscale(&#39;log&#39;)
plt.yscale(&#39;log&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/solutions_astrotwin_day_5_hands_on_13_0.png" src="_images/solutions_astrotwin_day_5_hands_on_13_0.png" />
</div>
</div>
</section>
<section id="modelling-part">
<h1>modelling part<a class="headerlink" href="#modelling-part" title="Link to this heading"></a></h1>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
from scipy.interpolate import interp1d

class constants:
    &quot;&quot;&quot;Useful constants&quot;&quot;&quot;
    G = 4.301e-9 #km^2 Mpc M_sun^-1 s^-2 gravitational constant
    H0 = 100. #h kms-1 Mpc-1 hubble constant at present
    omg_m = 0.315 #omega_matter
    not_so_tiny = 1e-24
class halo(constants):
    &quot;&quot;&quot;Useful functions for weak lensing signal modelling&quot;&quot;&quot;
    def __init__(self,m_tot,con_par):
        self.m_tot = m_tot # total mass of the halo
        self.c = con_par # concentration parameter
        self.rho_crt = 3*self.H0**2/(8*np.pi*self.G) # rho critical
        print(self.rho_crt*self.omg_m)
        self.r_200 = (3*m_tot/(4*np.pi*200*self.rho_crt*self.omg_m))**(1./3.) # radius defines size of the halo
        self.rho_0 = con_par**3 *m_tot/(4*np.pi*self.r_200**3 *(np.log(1.0+con_par)-con_par/(1.0+con_par)))
        self.init_sigma = False
        self.init_sigma_cir = False
        self.sigma_cir_dict = {}
        print((&quot;Intialing NFW parameters\n m_tot = %s M_sun\nconc_parm = %s\nrho_0 = %s M_sun/Mpc^3\n r_s = %s Mpc&quot;%(m_tot,con_par,self.rho_0,self.r_200/self.c)))

    def nfw(self,r):
        &quot;&quot;&quot;given r, this gives nfw profile as per the instantiated parameters&quot;&quot;&quot;
        r_s = self.r_200/self.c
        value  = self.rho_0/((r/r_s)*(1+r/r_s)**2)
        return value

    def sigma(self, r):
        r_s = self.r_200/self.c
        k = 2*r_s*self.rho_0
        if np.isscalar(r):
           r = np.array([r])
        sig = 0.0*r
        c=0
        for i in r:
            x = i/r_s
            if x &lt; 1:
                value = (1 - np.arccosh(1/x)/np.sqrt(1-x**2))/(x**2-1)
            elif x &gt; 1:
                value = (1 - np.arccos(1/x)/np.sqrt(x**2-1))/(x**2-1)
            else:
                value = 1./3.
            sig[c] = value*k
            c=c+1
        return sig

    def avg_sigma_nfw(self,r):
        r_s = self.r_200/self.c
        k = 2*r_s*self.rho_0
        c=0
        if np.isscalar(r):
            r = np.array([r])
        sig = 0.0*r
        for i in r:
            x = i/r_s
            if x &lt; 1:
                value = np.arccosh(1/x)/np.sqrt(1-x**2) + np.log(x/2.0)
                value = value*2.0/x**2
            elif x &gt; 1:
                value = np.arccos(1/x)/np.sqrt(x**2-1)  + np.log(x/2.0)
                value = value*2.0/x**2
            else:
                value = 2*(1-np.log(2))
            sig[c] = value*k
            c=c+1

        return sig


    def delta_sigma(self,r):
        &quot;&quot;&quot;difference between mean sigma and average over the circle of radius R&quot;&quot;&quot;
        val = self.avg_sigma_nfw(r) - self.sigma(r)
        return val


    &quot;&quot;&quot;segment for the parent halo contribution for the daughter halo at distance r0&quot;&quot;&quot;
    def sigma_cir(self,r,r0):
        &quot;&quot;&quot;sigma mean over a circle using the spline given below&quot;&quot;&quot;
        if not self.init_sigma_cir:
            self.init_sigma_cir_spl(r0)

        if r &gt; self.sigma_cir_dict[&quot;Rmax&quot;]:
            value = quad(lambda j: self.sigma(np.sqrt(r0**2 + r**2 + 2*r0*r*np.cos(j))), 0., 2*np.pi)[0]/(2*np.pi)
        elif r &lt; self.sigma_cir_dict[&quot;Rmin&quot;]:
            value = self.sigma_cir_dict[&quot;Sigmamin&quot;]
        else:
            value = 10**self.sig_cir_spl(np.log10(r))
        return value

    def init_sigma_cir_spl(self,r0):
        &quot;&quot;&quot;spline for the satellite at a distance r0 from the center for parents contribution averaged over a circle&quot;&quot;&quot;

        print(&quot;SPLINE READY FOR AVERAGING OVER CIRCLE&quot;)
        rdbin = np.logspace(-3,np.log10(10*self.r_200),50)
        des_cir = 0.0*rdbin
        for i  in range(0,len(rdbin)):
            des_cir[i] = quad(lambda j: self.sigma(np.sqrt(r0**2 + rdbin[i]**2 + 2*r0*rdbin[i]*np.cos(j))), 0., 2*np.pi)[0]/(2*np.pi)

        self.sig_cir_spl = interp1d(np.log10(rdbin), np.log10(des_cir),kind = &quot;cubic&quot;)
        self.sigma_cir_dict[&quot;Rmax&quot;] = rdbin[-1]
        self.sigma_cir_dict[&quot;Rmin&quot;] = rdbin[0]
        self.sigma_cir_dict[&quot;Sigmamin&quot;] = des_cir[0]
        self.init_sigma_cir = True
        return

    def delta_sigma_dau(self,r,r0):
        value =  2*np.pi*quad(lambda rp: rp*self.sigma_cir(rp,r0), 0.0, r)[0]/(np.pi*r**2) - self.sigma_cir(r,r0)
        #value =  self.sigma_cir(r,r0)
        return value


if __name__ == &quot;__main__&quot;:
    def proj_sat_profile(R):
        &quot;assumed dummy profile&quot;
        return 1/R**2

    rdbin = np.logspace(-2,np.log10(5),50)
    mhpart = 1e14
    mhdaut = 1e12
    msteldaut = 1e10

    h_p = halo(mhpart,4)
    h_d = halo(mhdaut,4)
    rd_dist =  0.3
    rsepmin = 0.1
    rsepmax = 0.6
    delta_part = 0.0*rdbin
    for i in range(len(rdbin)):
        #delta_part[i] = h_p.delta_sigma_dau(rdbin[i], rd_dist)
        ans = quad(lambda rsep: proj_sat_profile(rsep) *h_p.delta_sigma_dau(rdbin[i], rsep), rsepmin, rsepmax)[0]
        delta_part[i] = ans/quad(lambda rsep: proj_sat_profile(rsep), rsepmin, rsepmax)[0]


    plt.subplot(2,2,1)
    plt.plot(rdbin,delta_part/1e12,&#39;-&#39;, label = &#39;Parent&#39;)
    plt.plot(rdbin,(h_d.delta_sigma(rdbin) + msteldaut/(np.pi*rdbin**2))/1e12,&#39;-&#39;, label = &#39;Daughter&#39;)
    plt.plot(rdbin,(delta_part + msteldaut/(np.pi*rdbin**2) + h_d.delta_sigma(rdbin))/1e12,&#39;-&#39;, label = &#39;Total&#39;)
    plt.xscale(&#39;log&#39;)
    plt.legend()
    plt.axhline(0.0, ls=&#39;--&#39;,color=&#39;grey&#39;)
    plt.axvline(rd_dist, color=&#39;black&#39;)
    plt.xlabel(r&#39;$R [{ \rm h^{-1}Mpc}]$&#39;)
    plt.ylabel(r&#39;$\Delta \Sigma [{\rm h M_\odot pc^{-2}}]$&#39;)
    plt.savefig(&#39;test.png&#39;, dpi=300)
<br/><br/></pre></div>
</div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Divya Rana and Navin Chaurasiya.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>