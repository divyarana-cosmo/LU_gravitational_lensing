<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Day 3 - Get the Weak Lensing Signals &#8212; Weak gravitational lensing, Leiden 2025 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <link rel="stylesheet" type="text/css" href="_static/nbsphinx-code-cells.css?v=2aa19091" />
    <script src="_static/jquery.js?v=5d32c60e"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/documentation_options.js?v=cb975c41"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="Day-3---Get-the-Weak-Lensing-Signals">
<h1>Day 3 - Get the Weak Lensing Signals<a class="headerlink" href="#Day-3---Get-the-Weak-Lensing-Signals" title="Link to this heading"></a></h1>
<p>In this session, we will build a weak lensing measurement pipeline by utilizing the concepts covered in the previous two sessions. We will begin by outlining the various steps needed to prepare the pipeline. Then, we will implement each step as individual functions that can be called in our main code.</p>
<p>We are focusing on the matter distribution around SDSS redmapper galaxy clusters, as described in the paper <a class="reference external" href="https://arxiv.org/abs/1303.3562">arXiv:1303.3562</a>, using the weak lensing technique with shape catalogue data from HSC S16A (<a class="reference external" href="https://arxiv.org/abs/1705.06745">arXiv:1705.06745</a>). We recommend that readers familiarize themselves with these references to gain a better understanding of the data provided. Additionally, readers can compare their results with similar studies conducted on
these clusters using the shape catalogue from SDSS (<a class="reference external" href="https://arxiv.org/abs/1707.01907">arXiv:1707.01907</a>).</p>
<p><strong>We highly encourage readers to create a separate notebook for this session, as it will be useful for future reference.</strong></p>
<p><strong>In the code snippets provided below, you will notice some blanks indicated by ??. Please fill in the ?? with the appropriate equations and conversions.</strong></p>
<section id="Required-Steps">
<h2>Required Steps<a class="headerlink" href="#Required-Steps" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>Reading data from the catalog and appying the selection cuts.</p></li>
<li><p>Computing the tangential shear <span class="math notranslate nohighlight">\(e_{\rm t}\)</span> and inverse critical density <span class="math notranslate nohighlight">\(\Sigma^{-1}_{\rm crit}\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\Delta \Sigma (R)\)</span> measurements using cKDTree and writing the output to a file.</p></li>
<li><p>Plotting the weak lensing signal.</p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#loading the required packages
%matplotlib inline
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import cKDTree
from astropy.cosmology import FlatLambdaCDM
import glob
<br/></pre></div>
</div>
</div>
</section>
<section id="Reading-data-from-the-catalog-and-appying-the-selection-cuts.">
<h2>Reading data from the catalog and appying the selection cuts.<a class="headerlink" href="#Reading-data-from-the-catalog-and-appying-the-selection-cuts." title="Link to this heading"></a></h2>
<p>We are going to use the selection cuts on lensing sample in the day-1 session. The below code can be use for other cuts too but for now lets stick to defaults as given below.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># selection cut on the lens sample
def lens_select(zmin=0.1, zmax=0.33, lammin=55, lammax=100):
    #please check the file path properly
    data = pd.read_csv(&#39;/home/idies/workspace/Storage/divyar/AstroTwin_Colo_2024/DataStore/redmapper.dat&#39;, delim_whitespace=1)
    #sample selection cut
    idx  = (data[&#39;lambda&#39;]&gt;lammin) &amp; (data[&#39;lambda&#39;]&lt;=lammax)
    idx  = idx &amp; (data[&#39;zred&#39;]&gt;zmin) &amp; (data[&#39;zred&#39;]&lt;=zmax)
    ra   = data[&#39;ra&#39;].values[idx]
    dec  = data[&#39;dec&#39;].values[idx]
    zred = data[&#39;zred&#39;].values[idx]
    #as we have no weights to apply we set them to unity
    wgt  = ra*1.0/ra
    print(&#39;number of lenses=%d&#39;%len(ra))
    return ra, dec, zred, wgt
<br/></pre></div>
</div>
</div>
<p>Similar we define a function for sources and collect the data from it. Please note that there are many columns in source file but for now we are only using some of them. Here we are only using</p>
<ul class="simple">
<li><p>ra_gal, decgal : ra and dec for the sources</p></li>
<li><p>e1gal, e2gal: decribes the shapes of the sources</p></li>
<li><p>wgal, rms_egal: weights and Intrinsic shape dispersion per component</p></li>
<li><p>zphotgal: redshift of the sources</p></li>
</ul>
<p>For now we will neglect the data in other columns. As it is used for correcting the biases for our measurements and we will decribe how to use them at the end of this session.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def read_sources(ifil):
    # various columns in sources
    # ragal, decgal, e1gal, e2gal, wgal, rms_egal, mgal, c1gal, c2gal, R2gal, zphotgal
    data = pd.read_csv(ifil, delim_whitespace=1).values
    zphotgal = data[:,-1]
    # sanity checks on the sources data
    idx = (np.sum(np.isnan(data), axis=1)==0) &amp;  (zphotgal&gt;0)
    datagal = np.zeros((np.sum(idx),7))
    datagal[:,:6] = data[idx,:6]
    datagal[:,6]  = data[idx,-1]
    # collects only -  ragal, decgal, e1gal, e2gal, wgal, rms_egal, zphotgal
    return datagal
</pre></div>
</div>
</div>
</section>
<section id="Computing-the-tangential-shear-e_{\rm-t}-and-inverse-critical-density-\Sigma^{-1}_{\rm-crit}">
<h2>Computing the tangential shear <span class="math notranslate nohighlight">\(e_{\rm t}\)</span> and inverse critical density <span class="math notranslate nohighlight">\(\Sigma^{-1}_{\rm crit}\)</span><a class="headerlink" href="#Computing-the-tangential-shear-e_{\rm-t}-and-inverse-critical-density-\Sigma^{-1}_{\rm-crit}" title="Link to this heading"></a></h2>
<p>Now we will follow the formalism described in the lectures. We will first code up the function to compute the tangential component of the ellipticity given the positions for the lenses (<span class="math notranslate nohighlight">\(\alpha_l\)</span>, <span class="math notranslate nohighlight">\(\delta_l\)</span>) and sources(<span class="math notranslate nohighlight">\(\alpha_s\)</span>, <span class="math notranslate nohighlight">\(\delta_s\)</span>) along with the shape measurements (<span class="math notranslate nohighlight">\(e_1\)</span>,<span class="math notranslate nohighlight">\(e_2\)</span>) for the sources.</p>
<p>We will first compute angle <span class="math notranslate nohighlight">\(\theta\)</span> between a given lens-source pair.</p>
<div class="math notranslate nohighlight">
\[\cos \theta = \cos \delta_l \cos \delta_s \cos(\alpha_l - \alpha_s) + \sin\delta_l \sin \delta_s\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta_{l,s}\)</span> and <span class="math notranslate nohighlight">\(\alpha_{l,s}\)</span> are ra and dec for lens(l) and source(s). The tangential component of ellipticity <span class="math notranslate nohighlight">\(e_t\)</span> is given as</p>
<div class="math notranslate nohighlight">
\[e_t = - e_1 \cos 2\phi - e_2 \sin 2\phi\]</div>
<div class="math notranslate nohighlight">
\[\sin \phi = \frac{-\sin \delta_l \cos \delta_s + \cos \delta_l \sin \delta_s  \cos(\alpha_s - \alpha_l)}{|\sin\theta|}\]</div>
<div class="math notranslate nohighlight">
\[\cos \phi =  \frac{\cos\delta_l \sin(\alpha_s - \alpha_l)}{|\sin\theta|}\]</div>
<p>For more info related to the above equations refer to the notes for <a class="reference external" href="https://surhudm.github.io/Weaklensing_IAGRG/Weak_gravitational_lensing.html#Tangential-shear-computation">Tangential-shear-computation</a>. Please refer to these notes as the lectures are heavily based on them.</p>
<p>Coding up these equations requires trigonometric functions from the NumPy package. Please check them out - <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.sin.html">sin</a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.cos.html#numpy.cos">cos</a></p>
<p><strong>Please note that these functions by default use angles in radians and here we are working with catalogue data with (ra, dec) in degrees. So, we need to do the needful conversion first</strong></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># lra, ldec - lenses position
# sra, sdec - sources position
# se1 and se2 - source ellipticities
def get_et(lra, ldec, sra, sdec, se1, se2):
    # angle_in_radian = angle_in_degrees * np.pi/180
    return e_t
<br/></pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Exercise:</p>
<ul class="simple">
<li><p>Tell what are you getting the output for <span class="math notranslate nohighlight">\(e_t\)</span> if you use input lra=0.0, ldec=0.0, sra=0.123, sdec=0.045, se1 = 4.5e-2, se2 = 1.7e-2.</p></li>
<li><p>running command : <strong>print(get_et(lra=0.0, ldec=0.0, sra=0.123, sdec=0.045, se1 = 4.5e-2, se2 = 1.7e-2))</strong> in the next cell below the function defination cell. Please add cell below using the insert option on the top.</p></li>
</ul>
</div>
<p>We will now proceed to write a function that calculates <span class="math notranslate nohighlight">\(\Sigma^{-1}_{\rm crit}(z_l, z_s)\)</span> given the lens redshift <span class="math notranslate nohighlight">\(z_l\)</span> and source redshift <span class="math notranslate nohighlight">\(z_s\)</span> . This function will also require an instance of the Astropy cosmology class (denoted as <code class="docutils literal notranslate"><span class="pre">cc</span></code>). In the current code structure, we will initialize the Astropy cosmology class in our main code.</p>
<p>For reference, you can consult the Day-1 documentation to understand how Astropy is used for calculating cosmological distances.</p>
<p>Please note that we are working in comoving coordinates to perform the signal computations, and the corresponding formula for (<span class="math notranslate nohighlight">\(\Sigma^{-1}_{\rm crit}(z_l, z_s)\)</span>) is given by:</p>
<div class="math notranslate nohighlight">
\[\Sigma^{-1}_{\rm crit}(z_l, z_s) = \frac{4\pi G}{c^2} \frac{d_{\rm ang}(z_l) d_{\rm ang}(z_l, z_s) (1 + z_l)^2} {d_{\rm ang}(z_s)}\]</div>
<p>where <span class="math notranslate nohighlight">\(d_{\rm ang}(z)\)</span> represents the angular diameter distance for redshift (z).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def get_sigma_crit_inv(lzred, szred, cc):
    # some important constants for the sigma crit computations
    gee = 4.301e-9 #km^2 Mpc M_sun^-1 s^-2 gravitational constant
    cee = 3e5 #km s^-1
    # sigma_crit_calculations for a given lense-source pair
    sigm_crit_inv = 1e12*sigm_crit_inv #esd&#39;s are in pc not in Mpc
    return sigm_crit_inv
<br/></pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Exercise:</p>
<ul class="simple">
<li><p>In the cell below the function defination, first initiate the cosmo class from astropy using “<strong>cc = FlatLambdaCDM(H0=100, Om0=0.999)</strong>”.</p></li>
<li><p>running command : <strong>print(get_sigma_crit_inv(lzred=0.33, szred=0.8, cc=cc))</strong></p></li>
<li><p>Make a plot <span class="math notranslate nohighlight">\(\Sigma^{-1}_{c} (z_l, z_s = 0.8)\)</span> and <span class="math notranslate nohighlight">\(z_l\)</span> in range (0,0.8). Check how the plot varies if you change the Om0=0.3.</p></li>
<li><p>Make a plot <span class="math notranslate nohighlight">\(\Sigma^{-1}_{c} (z_l=0.3, z_s = 4.0)\)</span> and <span class="math notranslate nohighlight">\(z_s\)</span> in range (0.3,4.0).</p></li>
</ul>
</div>
<p>Remember how to convert from ra,dec (degrees) to x,y,z coordinates.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def get_xyz(ra, dec):
    return x, y, z
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Exercise:</p>
<ul class="simple">
<li><p>Tell the output of : <strong>print(get_xyz(30, 60))</strong></p></li>
</ul>
</div>
</section>
<section id="\Delta-\Sigma-measurements-using-cKDTree-and-writing-the-output-to-a-file.">
<h2><span class="math notranslate nohighlight">\(\Delta \Sigma\)</span> measurements using cKDTree and writing the output to a file.<a class="headerlink" href="#\Delta-\Sigma-measurements-using-cKDTree-and-writing-the-output-to-a-file." title="Link to this heading"></a></h2>
<p>Our aim in this section is to write the main function to measure weak lensing signal <span class="math notranslate nohighlight">\(\Delta \Sigma (R)\)</span>. As discussed in the lectures the <span class="math notranslate nohighlight">\(\Delta \Sigma (R)\)</span> for a comoving projected radial bin <span class="math notranslate nohighlight">\(R\)</span> as given by</p>
<div class="math notranslate nohighlight">
\[\Delta \Sigma (R) = \frac{\sum_{ls} w_{\rm ls} e_{t,ls} (\Sigma^{-1}_{\rm crit})^{-1}}{2\mathcal{R} \sum_{ls} w_{\rm ls}}\]</div>
<p>where <span class="math notranslate nohighlight">\(w_{ls}\)</span> is the source-lense weights given as <span class="math notranslate nohighlight">\(w_{ls} = w_l w_s \Sigma^{-2}_{\rm crit}\)</span> and the <span class="math notranslate nohighlight">\(\mathcal{R}\)</span> is the responsivity given as <span class="math notranslate nohighlight">\(\mathcal{R} = 1 - \frac{\sum_{\rm ls} w_{ls} e^2_{\rm rms}}{\sum_{\rm ls} w_{ls}}\)</span>. The <span class="math notranslate nohighlight">\(e_{\rm rms}\)</span> is the intrinsic shape dispersion given by the shape catalog for individual galaxies.</p>
<section id="Decription-of-algorithm-used-in-the-code-below-(run_pipe)-to-get-the-signal-\Delta-\Sigma.">
<h3>Decription of algorithm used in the code below (run_pipe) to get the signal <span class="math notranslate nohighlight">\(\Delta \Sigma\)</span>.<a class="headerlink" href="#Decription-of-algorithm-used-in-the-code-below-(run_pipe)-to-get-the-signal-\Delta-\Sigma." title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Global Input Parameters:</p>
<ol class="arabic simple">
<li><p><strong>Omegam</strong> : Omega matter - will be used in cosmological distance calculation, default = 0.315</p></li>
<li><p><strong>rmin</strong> : Minimum projected radius - will be used for setting projected radial range, default = 0.2</p></li>
<li><p><strong>rmax</strong> : Maximum projected radius - will be used for setting projected radial range, default = 2.0</p></li>
<li><p><strong>nbins</strong> : number of projected radial bins - use to setup the logarithmic binning, default = 10</p></li>
<li><p><strong>zdiff</strong> : a small offset added to lense redshift to select cleaner background sources <span class="math notranslate nohighlight">\(z_s &gt; (z_l + {\rm zdiff})\)</span>, default = 0.4</p></li>
<li><p><strong>outputfile</strong>: dat file name for the output, default = ‘astrotwin_dsigma.dat’</p></li>
</ol>
</li>
<li><p><strong>Initialize the astropy cosmo then getting projected radial binning array ready</strong></p></li>
<li><p>We are computing the numerators and denominators for the signals separately and they have to be initialize first:</p>
<ol class="arabic simple">
<li><p><strong>sumdsig_num</strong> : array for <span class="math notranslate nohighlight">\(\Delta\Sigma\)</span> numerator</p></li>
<li><p><strong>sumdsigsq_num</strong>: array for estimating the shape noise (covered in lectures) numerators</p></li>
<li><p><strong>sumwls</strong> : array for summed lense-source weights</p></li>
<li><p><strong>sumwls_resp</strong> : array for <span class="math notranslate nohighlight">\(\Delta\Sigma\)</span> numerator(we can push the 1 into summed w_ls - look at the expression)</p></li>
</ol>
</li>
<li><p>Collect lenses data and convert the position (ra,dec) –&gt; (x,y,z) using the above defined functions. Then use these x,y,z to get a lens tree using <strong>cKDtree</strong>.</p></li>
<li><p>We also need to set a <strong>maximum search radius</strong> for the <strong>query_ball_point</strong> (refer to day-2 tutorials). The maximum is theratio between maximum projected radius rmax and minimum comoving distance to our lense sample - <strong>rmax/(comoving_distance(zlmin))</strong>, zlmin - minimum lense redshift.</p></li>
<li><p>Now we use glob package to collect the file paths to our many many files. We loop over these path and read each file using the <strong>read_source</strong> function define above.</p></li>
<li><p>Then we take the source ra, dec and convert them to x,y,z so that we can <strong>query</strong> around each source using lense tree and collect lenses within <strong>maximum search radius</strong>. This will give us a list of ids of lenses for each sources.</p></li>
<li><p>Once we have a list of indices of lenses for all galaxies in the file. We then loop over the galaxies in individual file to compute the array of <strong>comoving projected radial distance</strong> for the each galaxy with it’s lenses that we got in the last step. Here we also put a cut that for a given lense-source pair with the source redshift <span class="math notranslate nohighlight">\(z_s\)</span> and lense redshift <span class="math notranslate nohighlight">\(z_l\)</span> , <span class="math notranslate nohighlight">\(z_s &gt; z_l +\)</span> zdiff and we also skip sources which doesn’t have any lense around them.</p></li>
<li><p>The projected distance array from last step then used to look for corresponding bin number in our binning scheme as described in the Global parameters. Then we use the above equations along with the above defined functions to get the values of array defined in step 3.</p></li>
<li><p>As said in step 6, we run step 7-9 for all the source files in our directory and then write the resultant output in a file named by the Global Parameters.</p></li>
</ol>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def run_pipe(Omegam=0.315, rmin=0.2, rmax=2.0, nbins=10, zdiff=0.4, outputfile = &#39;astrotwin_dsigma.dat&#39;):
    #set the cosmology with omegaM parameter
    cc = FlatLambdaCDM(H0=100, Om0=Omegam) # fixing H0=100 to set units in Mpc h-1

    # set the projected radial binning
    rmin  =  rmin
    rmax  =  rmax
    nbins = nbins #10 radial bins for our case
    rbins = np.logspace(np.log10(rmin), np.log10(rmax), nbins + 1)
    rdiff = np.log10(rbins[1]*1.0/rbins[0]) # difference in log binning

    # initializing arrays for signal compuations
    sumdsig_num   = np.zeros(len(rbins[:-1]))
    sumdsigsq_num = np.zeros(len(rbins[:-1]))
    sumwls        = np.zeros(len(rbins[:-1]))
    sumwls_resp   = np.zeros(len(rbins[:-1]))

    # getting the lenses data
    lra, ldec, lred, lwgt = ??
    # convert lense ra and dec into x,y,z cartesian coordinates
    lx, ly, lz = ??
    # putting kd tree around the lenses
    lens_tree = ??
    print(&#39;lenses tree is ready\n&#39;)

    # setting maximum search radius
    dcommin = cc.comoving_distance(np.min(lred)).value
    dismax  = (rmax*1.0/(dcommin))

    # lets first catch the file list for sources
    sflist = np.sort(glob.glob(&#39;/home/idies/workspace/Storage/divyar/AstroTwin_Colo_2024/DataStore/hsc/*.dat&#39;))

    # Ready to pounce on the source data
    for ifil in sflist:
        # source data in datagal array  using read source function
        datagal = ??
        Ngal = len(datagal[:,0])  # total number of galaxies in the source file

        # first two entries are ra and dec for the sources
        allragal  = datagal[:,0]
        alldecgal = datagal[:,1]

        # ra and dec to x,y,z for sources
        allsx, allsy, allsz = ??

        # query in a ball around individual sources and collect the lenses ids with a maximum radius
        slidx = lens_tree.query_ball_point(np.transpose([allsx, allsy, allsz]), dismax)

        # looping over all the galaxies
        for igal in range(Ngal):
            ragal    = datagal[igal,0]
            decgal   = datagal[igal,1]
            e1gal    = datagal[igal,2]
            e2gal    = datagal[igal,3]
            wgal     = datagal[igal,4]
            rms_egal = datagal[igal,5]
            zphotgal = datagal[igal,6]

            # array of lenses indices
            lidx = np.array(slidx[igal])

            # skip sources which doesn&#39;t have any lenses around them
            if len(lidx)==0:
                continue

            # selecting a cleaner background
            zcut = (lred[lidx] &lt; (zphotgal - zdiff)) #only taking the foreground lenses

            # again skipping the onces which doesn&#39;t satisfy the above criteria
            if np.sum(zcut)==0.0:
                continue

            # collecting the  data of lenses around individual source
            lidx   = lidx[zcut] # this will catch the array indices for our lenses
            sra    = ragal
            sdec   = decgal

            l_ra   = lra[lidx]
            l_dec  = ldec[lidx]
            l_zred = lred[lidx]
            l_wgt  = lwgt[lidx]

            sx, sy, sz = ?? # individual galaxy sra,sdec--&gt;sx,sy,sz
            lx, ly, lz = ?? # individual galaxy lra,ldec--&gt;lx,ly,lz

            # getting the radial separations for a lense source pair
            sl_sep = np.sqrt((lx - sx)**2 + (ly - sy)**2 + (lz - sz)**2)
            sl_sep = sl_sep * cc.comoving_distance(l_zred).value

            # here we are binning the separation in projected radial bins
            # ll will enumerate the lenses
            for ll,sep in enumerate(sl_sep):

                #check whether separation sits inside our projected radial range
                if sep&lt;rmin or sep&gt;rmax:
                    continue

                # finding the corresponding radial bins for separations
                rb = int(np.log10(sep*1.0/rmin)*1/rdiff)

                # get tangantial components given positions and shapes
                e_t = ??(lra = l_ra[ll], ldec = l_dec[ll], sra = ??, sdec = ??, se? = ??,  se? = ??)

                # sigma_crit_calculations for a given lense-source pair with cc as astropy cosmo instance
                sigm_crit_inv = ??(l_zred[ll], ??, cc)

                # following equations given in the lectures
                w_ls    = l_wgt[ll] * wgal * (sigm_crit_inv)**2
                w_ls_by_av_sigc_inv = l_wgt[ll] * ?? * sigm_crit_inv

                # separate numerator and denominator computation
                sumdsig_num[rb]   += w_ls_by_av_sigc_inv  * e_t
                sumdsigsq_num[rb] += (w_ls_by_av_sigc_inv * e_t)**2
                sumwls[rb]        += w_ls
                sumwls_resp[rb]   += w_ls * (1-rms_egal**2)

        print(ifil)

    outputfile = outputfile
    fout = open(outputfile, &quot;w&quot;)
    fout.write(&quot;# 0:rmin/2+rmax/2 1:DeltaSigma  2:SN_ErrDeltaSigma\n&quot;)
    for i in range(len(rbins[:-1])):
        rrmin = rbins[i]
        rrmax = rbins[i+1]
        Resp       = sumwls_resp[i]*1.0/sumwls[i]
        dsigma     = sumdsig_num[i]*1.0/sumwls[i]/2./Resp # follow from the equation above
        dsigma_err = np.sqrt(sumdsigsq_num[i])*1.0/sumwls[i]/2./Resp

        fout.write(&quot;%le\t%le\t%le\n&quot;%(rrmin/2.0+rrmax/2.0, dsigma, dsigma_err))
    fout.write(&quot;#OK&quot;)
    fout.close()

    return 0
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>run_pipe()
</pre></div>
</div>
</div>
</section>
</section>
<section id="Plotting-the-weak-lensing-signal">
<h2>Plotting the weak lensing signal<a class="headerlink" href="#Plotting-the-weak-lensing-signal" title="Link to this heading"></a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>dat = np.loadtxt(&#39;astrotwin_dsigma.dat&#39;)

plt.errorbar(dat[:,0], dat[:,1], yerr=dat[:,2], fmt=&#39;.&#39;, capsize=3, label=&#39;Data&#39;)
plt.legend()

plt.xlabel(r&#39;$R[{\rm h^{-1}Mpc}]$&#39;)
plt.ylabel(r&#39;$\Delta\Sigma [{\rm h M_\odot pc^{-2}}]$&#39;)
plt.xscale(&#39;log&#39;)
plt.yscale(&#39;log&#39;)
</pre></div>
</div>
</div>
</section>
<section id="The-bias-corrected-measurements">
<h2>The bias corrected measurements<a class="headerlink" href="#The-bias-corrected-measurements" title="Link to this heading"></a></h2>
<p>For doing a bias corrected measurements one has to add few more things in our <span class="math notranslate nohighlight">\(\Delta \Sigma\)</span> expression. Interested reader can check this expression for <span class="math notranslate nohighlight">\(\Delta \Sigma\)</span> in <a class="reference external" href="https://arxiv.org/abs/2107.05641">arXiv:2107.05641</a> and can modify the above code to get the bias corrected measurements.</p>
<p>Please note that within each source file we have already provided you the data columns required to do these computations.</p>
<p>Here you coded up the weak lensing signal measurement pipeline. But we strongly suggest you to look at the python package - <a class="reference external" href="https://dsigma.readthedocs.io/en/latest/">dsigma</a> as the package covers all the aspects of the weak lensing pipeline and can be a handy tool to use and get the signals.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Weak gravitational lensing, Leiden</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="astrotwin_day_1_hands_on.html">Day 1 - Introduction</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Divya Rana.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/astrotwin_day_3_hands_on.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>