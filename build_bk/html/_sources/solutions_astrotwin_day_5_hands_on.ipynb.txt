{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Day 5 Solutions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "#loading the required packages\n",
    "%matplotlib inline\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.spatial import cKDTree\n",
    "from astropy.cosmology import FlatLambdaCDM\n",
    "import glob\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_xyz(ra, dec):\n",
    "    ra = ra*np.pi/180.\n",
    "    dec = dec*np.pi/180.\n",
    "    x = np.cos(dec)*np.cos(ra)\n",
    "    y = np.cos(dec)*np.sin(ra)\n",
    "    z = np.sin(dec) \n",
    "    return x, y, z\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(0.43301270189221946, 0.25, 0.8660254037844386)\n"
     ]
    }
   ],
   "source": [
    "print(get_xyz(30,60))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# selection cut on the lens sample\n",
    "def lens_select(zmin=0.1, zmax=0.33, rsepmin=0.1, rsepmax=0.4):\n",
    "    #please check the file path properly \n",
    "    data = pd.read_csv('/home/idies/workspace/Storage/divyar/AstroTwin_Colo_2024/DataStore/redmapper_satellites.dat', delim_whitespace=1)\n",
    "    #sample selection cut\n",
    "    idx  = (data['rsep[h-1Mpc]']>rsepmin) & (data['rsep[h-1Mpc]']<=rsepmax)\n",
    "    idx  = idx & (data['zred']>zmin) & (data['zred']<=zmax)\n",
    "    ra   = data['ra'].values[idx]\n",
    "    dec  = data['dec'].values[idx]\n",
    "    zred = data['zred'].values[idx]\n",
    "    #as we have no weights to apply we set them to unity\n",
    "    wgt  = ra*1.0/ra\n",
    "    print('number of lenses=%d'%len(ra))\n",
    "    return ra, dec, zred, wgt\n",
    "\n",
    "\n",
    "\n",
    "# def lens_select(zmin=0.1, zmax=0.33, lammin=55, lammax=100):\n",
    "#     #please check the file path properly \n",
    "#     data = pd.read_csv('/home/idies/workspace/Storage/divyar/AstroTwin_Colo_2024/DataStore/redmapper.dat', delim_whitespace=1)\n",
    "#     #sample selection cut\n",
    "#     idx  = (data['lambda']>lammin) & (data['lambda']<=lammax)\n",
    "#     idx  = idx & (data['zred']>zmin) & (data['zred']<=zmax)\n",
    "#     ra   = data['ra'].values[idx]\n",
    "#     dec  = data['dec'].values[idx]\n",
    "#     zred = data['zred'].values[idx]\n",
    "#     #as we have no weights to apply we set them to unity\n",
    "#     wgt  = ra*1.0/ra\n",
    "#     print('number of lenses=%d'%len(ra))\n",
    "#     return ra, dec, zred, wgt\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# sanity cheaks on the source files\n",
    "def read_sources(ifil):\n",
    "    # various columns in sources \n",
    "    # ragal, decgal, e1gal, e2gal, wgal, rms_egal, mgal, c1gal, c2gal, R2gal, zphotgal\n",
    "    data = pd.read_csv(ifil, delim_whitespace=1).values\n",
    "    zphotgal = data[:,-1]\n",
    "    # sanity checks on the sources data\n",
    "    idx = (np.sum(np.isnan(data), axis=1)==0) &  (zphotgal>0)\n",
    "    datagal = np.zeros((np.sum(idx),7))\n",
    "    datagal[:,:6] = data[idx,:6]\n",
    "    datagal[:,6]  = data[idx,-1]\n",
    "    # collects only -  ragal, decgal, e1gal, e2gal, wgal, rms_egal, zphotgal\n",
    "    return datagal"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# following surhud's lectures\n",
    "def get_et(lra, ldec, sra, sdec, se1, se2):\n",
    "    lra  = lra*np.pi/180\n",
    "    ldec = ldec*np.pi/180\n",
    "    sra  = sra*np.pi/180\n",
    "    sdec = sdec*np.pi/180\n",
    "\n",
    "    c_theta = np.cos(ldec)*np.cos(sdec)*np.cos(lra - sra) + np.sin(ldec)*np.sin(sdec)\n",
    "    s_theta = np.sqrt(1-c_theta**2)\n",
    "\n",
    "    # phi to get the compute the tangential shear\n",
    "    c_phi   = np.cos(ldec)*np.sin(sra - lra)*1.0/s_theta\n",
    "    s_phi   = (-np.sin(ldec)*np.cos(sdec) + np.cos(ldec)*np.cos(sra - lra)*np.sin(sdec))*1.0/s_theta\n",
    "    # tangential shear\n",
    "    e_t     = - se1*(2*c_phi**2 -1) - se2*(2*c_phi * s_phi)\n",
    "\n",
    "    return e_t"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-0.04534629189830734\n"
     ]
    }
   ],
   "source": [
    "print(get_et(lra=0, ldec=0, sra=0.123, sdec=0.045, se1 = 4.5e-2, se2 = 1.7e-2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_sigma_crit_inv(lzred, szred, cc):\n",
    "    # some important constants for the sigma crit computations\n",
    "    gee = 4.301e-9 #km^2 Mpc M_sun^-1 s^-2 gravitational constant\n",
    "    cee = 3e5 #km s^-1\n",
    "    # sigma_crit_calculations for a given lense-source pair\n",
    "    sigm_crit_inv = cc.angular_diameter_distance(lzred).value * cc.angular_diameter_distance_z1z2(lzred, szred).value * (1.0 + lzred)**2 * 1.0/cc.angular_diameter_distance(szred).value\n",
    "    sigm_crit_inv = sigm_crit_inv * 4*np.pi*gee*1.0/cee**2 \n",
    "    sigm_crit_inv = 1e12*sigm_crit_inv #esd's are in pc not in Mpc\n",
    "\n",
    "    return sigm_crit_inv"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.00030436585298495184\n"
     ]
    }
   ],
   "source": [
    "from astropy.cosmology import FlatLambdaCDM\n",
    "cc = FlatLambdaCDM(H0=100, Om0=0.999)\n",
    "print(get_sigma_crit_inv(lzred=0.33, szred=0.8, cc=cc))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def run_pipe(Omegam=0.315, rmin=0.2, rmax=2.0, nbins=10, zdiff=0.4, outputfile = 'astrotwin_dsigma.dat'):\n",
    "    #set the cosmology with omegaM parameter \n",
    "    cc = FlatLambdaCDM(H0=100, Om0=Omegam) # fixing H0=100 to set units in Mpc h-1\n",
    "    \n",
    "    # set the projected radial binning \n",
    "    rmin  =  rmin\n",
    "    rmax  =  rmax\n",
    "    nbins = nbins #10 radial bins for our case\n",
    "    rbins  = np.logspace(np.log10(rmin), np.log10(rmax), nbins + 1)\n",
    "    rdiff  = np.log10(rbins[1]*1.0/rbins[0])\n",
    " \n",
    "    # initializing arrays for signal compuations\n",
    "    sumdsig_num   = np.zeros(len(rbins[:-1]))\n",
    "    sumdsigsq_num = np.zeros(len(rbins[:-1]))\n",
    "    sumwls        = np.zeros(len(rbins[:-1]))\n",
    "    sumwls_resp   = np.zeros(len(rbins[:-1]))\n",
    "\n",
    "    # getting the lenses data\n",
    "    lra, ldec, lred, lwgt = lens_select()\n",
    "    #lra, ldec, lred, lwgt = lens_select(zmin=0.1, zmax=0.33, lammin=55, lammax=100)\n",
    "\n",
    "    # convert lense ra and dec into x,y,z cartesian coordinates\n",
    "    lx, ly, lz = get_xyz(lra, ldec)\n",
    "     \n",
    "    # putting kd tree around the lenses\n",
    "    lens_tree = cKDTree(np.array([lx, ly, lz]).T)\n",
    "    \n",
    "    \n",
    "    print('lenses tree is ready\\n')\n",
    "    \n",
    "    # setting maximum search radius\n",
    "    dcommin = cc.comoving_distance(np.min(lred)).value\n",
    "    dismax  = (rmax*1.0/(dcommin)) \n",
    "\n",
    "    # lets first catch the file list for sources\n",
    "    sflist = np.sort(glob.glob('/home/idies/workspace/Storage/divyar/AstroTwin_Colo_2024/DataStore/hsc/*.dat'))\n",
    "\n",
    "    # Ready to pounce on the source data\n",
    "    for ifil in sflist:\n",
    "        # catching the source data matrix\n",
    "        # please have a check for the columns names\n",
    "        datagal = read_sources(ifil)\n",
    "        Ngal = len(datagal[:,0])  # total number of galaxies in the source file\n",
    "        # first two entries are ra and dec for the sources\n",
    "        allragal  = datagal[:,0]\n",
    "        alldecgal = datagal[:,1]\n",
    "        # ra and dec to x,y,z for sources\n",
    "        allsx, allsy, allsz = get_xyz(allragal, alldecgal)\n",
    "        # query in a ball around individual sources and collect the lenses ids with a maximum radius\n",
    "        slidx = lens_tree.query_ball_point(np.transpose([allsx, allsy, allsz]), dismax) \n",
    "        # various columns in sources \n",
    "        # ragal, decgal, e1gal, e2gal, wgal, rms_egal, mgal, c1gal, c2gal, R2gal, zphotgal\n",
    "        # looping over all the galaxies\n",
    "        for igal in range(Ngal):    \n",
    "            ragal    = datagal[igal,0]\n",
    "            decgal   = datagal[igal,1]\n",
    "            e1gal    = datagal[igal,2]\n",
    "            e2gal    = datagal[igal,3]\n",
    "            wgal     = datagal[igal,4]\n",
    "            rms_egal = datagal[igal,5]\n",
    "            zphotgal = datagal[igal,6]\n",
    "           \n",
    "            # array of lenses indices\n",
    "            lidx = np.array(slidx[igal])\n",
    "            # removing sources which doesn't have any lenses around them \n",
    "            if len(lidx)==0:\n",
    "                continue\n",
    "           \n",
    "            # selecting a cleaner background\n",
    "            zcut = (lred[lidx] < (zphotgal - zdiff)) #only taking the foreground lenses\n",
    "            # again skipping the onces which doesn't satisfy the above criteria\n",
    "            if np.sum(zcut)==0.0:\n",
    "                continue\n",
    "            # collecting the  data of lenses around individual source\n",
    "            lidx   = lidx[zcut] # this will catch the array indices for our lenses\n",
    "            sra    = ragal\n",
    "            sdec   = decgal\n",
    "            \n",
    "            l_ra   = lra[lidx]\n",
    "            l_dec  = ldec[lidx]\n",
    "            l_zred = lred[lidx] \n",
    "            l_wgt  = lwgt[lidx] \n",
    "           \n",
    "            sx, sy, sz = get_xyz(sra,sdec) # individual galaxy ra,dec-->x,y,z\n",
    "            lx, ly, lz = get_xyz(l_ra,l_dec) # individual galaxy ra,dec-->x,y,z\n",
    "            \n",
    "            # getting the radial separations for a lense source pair \n",
    "            sl_sep = np.sqrt((lx - sx)**2 + (ly - sy)**2 + (lz - sz)**2)\n",
    "            sl_sep = sl_sep * cc.comoving_distance(l_zred).value\n",
    "            for ll,sep in enumerate(sl_sep):\n",
    "                if sep<rmin or sep>rmax:\n",
    "                    continue\n",
    "                rb = int(np.log10(sep*1.0/rmin)*1/rdiff)\n",
    "               \n",
    "                # get tangantial components given positions and shapes\n",
    "                e_t = get_et(lra = l_ra[ll], ldec = l_dec[ll], sra = sra, sdec = sdec, se1 = e1gal,  se2 = e2gal)\n",
    "\n",
    "                # sigma_crit_calculations for a given lense-source pair\n",
    "                sigm_crit_inv = get_sigma_crit_inv(l_zred[ll], zphotgal, cc)\n",
    "\n",
    "                # following equations given in the surhud's lectures \n",
    "                w_ls    = l_wgt[ll] * wgal * (sigm_crit_inv)**2\n",
    "                w_ls_by_av_sigc_inv = l_wgt[ll] * wgal * sigm_crit_inv\n",
    "\n",
    "                # separate numerator and denominator computation   \n",
    "                sumdsig_num[rb]   += w_ls_by_av_sigc_inv  * e_t\n",
    "                sumdsigsq_num[rb] += (w_ls_by_av_sigc_inv * e_t)**2\n",
    "                sumwls[rb]        += w_ls\n",
    "                sumwls_resp[rb]   += w_ls * (1-rms_egal**2)\n",
    "\n",
    "        print(ifil)\n",
    "        \n",
    "      \n",
    "    fout = open(outputfile, \"w\")\n",
    "    fout.write(\"# 0:rmin/2+rmax/2 1:DeltaSigma 2:SN_ErrDeltaSigma\\n\")\n",
    "    for i in range(len(rbins[:-1])):\n",
    "        rrmin = rbins[i]\n",
    "        rrmax = rbins[i+1]\n",
    "        Resp = sumwls_resp[i]*1.0/sumwls[i]\n",
    "        \n",
    "        fout.write(\"%le\\t%le\\t%le\\n\"%(rrmin/2.0+rrmax/2.0, sumdsig_num[i]*1.0/sumwls[i]/2./Resp, np.sqrt(sumdsigsq_num[i])*1.0/sumwls[i]/2./Resp))\n",
    "    fout.write(\"#OK\")    \n",
    "    fout.close()\n",
    "    \n",
    "    return 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#run_pipe(rmin=0.01,rmax=3, outputfile = '/home/idies/workspace/Storage/divyar/persistent/astrotwin_dsigma_satellite.dat')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dat = np.loadtxt('astrotwin_dsigma_satellite.dat')\n",
    "\n",
    "plt.errorbar(dat[:,0], dat[:,1], yerr=dat[:,2], fmt='.', capsize=3, label='Data')\n",
    "plt.legend()\n",
    "\n",
    "plt.xlabel(r'$R[{\\rm h^{-1}Mpc}]$')\n",
    "plt.ylabel(r'$\\Delta\\Sigma [{\\rm h M_\\odot pc^{-2}}]$')\n",
    "plt.xscale('log')\n",
    "plt.yscale('log')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "dat = np.loadtxt('astrotwin_dsigma.dat')\n",
    "\n",
    "plt.errorbar(dat[:,0], dat[:,1], yerr=dat[:,2], fmt='.', capsize=3, label='Data')\n",
    "plt.legend()\n",
    "\n",
    "plt.xlabel(r'$R[{\\rm h^{-1}Mpc}]$')\n",
    "plt.ylabel(r'$\\Delta\\Sigma [{\\rm h M_\\odot pc^{-2}}]$')\n",
    "plt.xscale('log')\n",
    "plt.yscale('log')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# modelling part"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.integrate import quad\n",
    "from scipy.interpolate import interp1d\n",
    "\n",
    "class constants:\n",
    "    \"\"\"Useful constants\"\"\"\n",
    "    G = 4.301e-9 #km^2 Mpc M_sun^-1 s^-2 gravitational constant\n",
    "    H0 = 100. #h kms-1 Mpc-1 hubble constant at present\n",
    "    omg_m = 0.315 #omega_matter\n",
    "    not_so_tiny = 1e-24\n",
    "class halo(constants):\n",
    "    \"\"\"Useful functions for weak lensing signal modelling\"\"\"\n",
    "    def __init__(self,m_tot,con_par):\n",
    "        self.m_tot = m_tot # total mass of the halo\n",
    "        self.c = con_par # concentration parameter\n",
    "        self.rho_crt = 3*self.H0**2/(8*np.pi*self.G) # rho critical\n",
    "        print(self.rho_crt*self.omg_m)\n",
    "        self.r_200 = (3*m_tot/(4*np.pi*200*self.rho_crt*self.omg_m))**(1./3.) # radius defines size of the halo\n",
    "        self.rho_0 = con_par**3 *m_tot/(4*np.pi*self.r_200**3 *(np.log(1.0+con_par)-con_par/(1.0+con_par)))\n",
    "        self.init_sigma = False\n",
    "        self.init_sigma_cir = False\n",
    "        self.sigma_cir_dict = {}\n",
    "        print((\"Intialing NFW parameters\\n m_tot = %s M_sun\\nconc_parm = %s\\nrho_0 = %s M_sun/Mpc^3\\n r_s = %s Mpc\"%(m_tot,con_par,self.rho_0,self.r_200/self.c)))\n",
    "\n",
    "    def nfw(self,r):\n",
    "        \"\"\"given r, this gives nfw profile as per the instantiated parameters\"\"\"\n",
    "        r_s = self.r_200/self.c\n",
    "        value  = self.rho_0/((r/r_s)*(1+r/r_s)**2)\n",
    "        return value\n",
    "\n",
    "    def sigma(self, r):\n",
    "        r_s = self.r_200/self.c\n",
    "        k = 2*r_s*self.rho_0\n",
    "        if np.isscalar(r):\n",
    "           r = np.array([r])\n",
    "        sig = 0.0*r\n",
    "        c=0\n",
    "        for i in r:\n",
    "            x = i/r_s\n",
    "            if x < 1:\n",
    "                value = (1 - np.arccosh(1/x)/np.sqrt(1-x**2))/(x**2-1)\n",
    "            elif x > 1:\n",
    "                value = (1 - np.arccos(1/x)/np.sqrt(x**2-1))/(x**2-1)\n",
    "            else:\n",
    "                value = 1./3.\n",
    "            sig[c] = value*k\n",
    "            c=c+1\n",
    "        return sig\n",
    "\n",
    "    def avg_sigma_nfw(self,r):\n",
    "        r_s = self.r_200/self.c\n",
    "        k = 2*r_s*self.rho_0\n",
    "        c=0\n",
    "        if np.isscalar(r):\n",
    "            r = np.array([r])\n",
    "        sig = 0.0*r\n",
    "        for i in r:\n",
    "            x = i/r_s\n",
    "            if x < 1:\n",
    "                value = np.arccosh(1/x)/np.sqrt(1-x**2) + np.log(x/2.0)\n",
    "                value = value*2.0/x**2\n",
    "            elif x > 1:\n",
    "                value = np.arccos(1/x)/np.sqrt(x**2-1)  + np.log(x/2.0)\n",
    "                value = value*2.0/x**2\n",
    "            else:\n",
    "                value = 2*(1-np.log(2))\n",
    "            sig[c] = value*k\n",
    "            c=c+1\n",
    "\n",
    "        return sig\n",
    "\n",
    "\n",
    "    def delta_sigma(self,r):\n",
    "        \"\"\"difference between mean sigma and average over the circle of radius R\"\"\"\n",
    "        val = self.avg_sigma_nfw(r) - self.sigma(r)\n",
    "        return val\n",
    "\n",
    "\n",
    "    \"\"\"segment for the parent halo contribution for the daughter halo at distance r0\"\"\"\n",
    "    def sigma_cir(self,r,r0):\n",
    "        \"\"\"sigma mean over a circle using the spline given below\"\"\"\n",
    "        if not self.init_sigma_cir:\n",
    "            self.init_sigma_cir_spl(r0)\n",
    "\n",
    "        if r > self.sigma_cir_dict[\"Rmax\"]:\n",
    "            value = quad(lambda j: self.sigma(np.sqrt(r0**2 + r**2 + 2*r0*r*np.cos(j))), 0., 2*np.pi)[0]/(2*np.pi)\n",
    "        elif r < self.sigma_cir_dict[\"Rmin\"]:\n",
    "            value = self.sigma_cir_dict[\"Sigmamin\"]\n",
    "        else:\n",
    "            value = 10**self.sig_cir_spl(np.log10(r))\n",
    "        return value\n",
    "\n",
    "    def init_sigma_cir_spl(self,r0):\n",
    "        \"\"\"spline for the satellite at a distance r0 from the center for parents contribution averaged over a circle\"\"\"\n",
    "\n",
    "        print(\"SPLINE READY FOR AVERAGING OVER CIRCLE\")\n",
    "        rdbin = np.logspace(-3,np.log10(10*self.r_200),50)\n",
    "        des_cir = 0.0*rdbin\n",
    "        for i  in range(0,len(rdbin)):\n",
    "            des_cir[i] = quad(lambda j: self.sigma(np.sqrt(r0**2 + rdbin[i]**2 + 2*r0*rdbin[i]*np.cos(j))), 0., 2*np.pi)[0]/(2*np.pi)\n",
    "\n",
    "        self.sig_cir_spl = interp1d(np.log10(rdbin), np.log10(des_cir),kind = \"cubic\")\n",
    "        self.sigma_cir_dict[\"Rmax\"] = rdbin[-1]\n",
    "        self.sigma_cir_dict[\"Rmin\"] = rdbin[0]\n",
    "        self.sigma_cir_dict[\"Sigmamin\"] = des_cir[0]\n",
    "        self.init_sigma_cir = True\n",
    "        return\n",
    "\n",
    "    def delta_sigma_dau(self,r,r0):\n",
    "        value =  2*np.pi*quad(lambda rp: rp*self.sigma_cir(rp,r0), 0.0, r)[0]/(np.pi*r**2) - self.sigma_cir(r,r0)\n",
    "        #value =  self.sigma_cir(r,r0)\n",
    "        return value\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    def proj_sat_profile(R):\n",
    "        \"assumed dummy profile\"\n",
    "        return 1/R**2\n",
    "\n",
    "    rdbin = np.logspace(-2,np.log10(5),50)\n",
    "    mhpart = 1e14\n",
    "    mhdaut = 1e12\n",
    "    msteldaut = 1e10\n",
    "\n",
    "    h_p = halo(mhpart,4)\n",
    "    h_d = halo(mhdaut,4)\n",
    "    rd_dist =  0.3\n",
    "    rsepmin = 0.1\n",
    "    rsepmax = 0.6\n",
    "    delta_part = 0.0*rdbin\n",
    "    for i in range(len(rdbin)):\n",
    "        #delta_part[i] = h_p.delta_sigma_dau(rdbin[i], rd_dist)\n",
    "        ans = quad(lambda rsep: proj_sat_profile(rsep) *h_p.delta_sigma_dau(rdbin[i], rsep), rsepmin, rsepmax)[0]\n",
    "        delta_part[i] = ans/quad(lambda rsep: proj_sat_profile(rsep), rsepmin, rsepmax)[0]\n",
    "\n",
    "\n",
    "    plt.subplot(2,2,1)\n",
    "    plt.plot(rdbin,delta_part/1e12,'-', label = 'Parent')\n",
    "    plt.plot(rdbin,(h_d.delta_sigma(rdbin) + msteldaut/(np.pi*rdbin**2))/1e12,'-', label = 'Daughter')\n",
    "    plt.plot(rdbin,(delta_part + msteldaut/(np.pi*rdbin**2) + h_d.delta_sigma(rdbin))/1e12,'-', label = 'Total')\n",
    "    plt.xscale('log')\n",
    "    plt.legend()\n",
    "    plt.axhline(0.0, ls='--',color='grey')\n",
    "    plt.axvline(rd_dist, color='black')\n",
    "    plt.xlabel(r'$R [{ \\rm h^{-1}Mpc}]$')\n",
    "    plt.ylabel(r'$\\Delta \\Sigma [{\\rm h M_\\odot pc^{-2}}]$')\n",
    "    plt.savefig('test.png', dpi=300)\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
